using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ProjectAvalonia.Generators;

[Generator]
public class StaticViewLocatorGenerator : ISourceGenerator
{
    private const string StaticViewLocatorAttributeDisplayString = "ProjectAvalonia.StaticViewLocatorAttribute";

    private const string ViewModelSuffix = "ViewModel";

    private const string ViewSuffix = "View";

    private const string AttributeText = @"// <auto-generated />
using System;

namespace ProjectAvalonia
{
	[AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
	public sealed class StaticViewLocatorAttribute : Attribute
	{
	}
}";

    public void Initialize(
        GeneratorInitializationContext context
    )
    {
        // System.Diagnostics.Debugger.Launch();
        context.RegisterForPostInitialization(callback: i => i.AddSource(hintName: "StaticViewLocatorAttribute.cs"
            , sourceText: SourceText.From(text: AttributeText, encoding: Encoding.UTF8)));

        context.RegisterForSyntaxNotifications(receiverCreator: () => new SyntaxReceiver());
    }

    public void Execute(
        GeneratorExecutionContext context
    )
    {
        if (context.SyntaxContextReceiver is not SyntaxReceiver receiver)
        {
            return;
        }

        var attributeSymbol =
            context.Compilation.GetTypeByMetadataName(
                fullyQualifiedMetadataName: StaticViewLocatorAttributeDisplayString);
        if (attributeSymbol is null)
        {
            return;
        }

        foreach (var namedTypeSymbol in receiver.NamedTypeSymbolLocators)
        {
            var namedTypeSymbolViewModels = receiver.NamedTypeSymbolViewModels.ToList();
            namedTypeSymbolViewModels.Sort(comparison: (
                x
                , y
            ) => x.ToDisplayString().CompareTo(strB: y.ToDisplayString()));

            var classSource = ProcessClass(compilation: context.Compilation, namedTypeSymbolLocator: namedTypeSymbol
                , namedTypeSymbolViewModels: namedTypeSymbolViewModels);
            if (classSource is not null)
            {
                context.AddSource(hintName: $"{namedTypeSymbol.Name}_StaticViewLocator.cs"
                    , sourceText: SourceText.From(text: classSource, encoding: Encoding.UTF8));
            }
        }
    }

    private static string? ProcessClass(
        Compilation compilation
        , INamedTypeSymbol namedTypeSymbolLocator
        , List<INamedTypeSymbol> namedTypeSymbolViewModels
    )
    {
        if (!namedTypeSymbolLocator.ContainingSymbol.Equals(other: namedTypeSymbolLocator.ContainingNamespace
                , equalityComparer: SymbolEqualityComparer.Default))
        {
            return null;
        }

        var namespaceNameLocator = namedTypeSymbolLocator.ContainingNamespace.ToDisplayString();

        var format = new SymbolDisplayFormat(
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypes,
            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters |
                             SymbolDisplayGenericsOptions.IncludeTypeConstraints |
                             SymbolDisplayGenericsOptions.IncludeVariance);

        var classNameLocator = namedTypeSymbolLocator.ToDisplayString(format: format);

        var source = new StringBuilder(value: $@"// <auto-generated />
#nullable enable
using System;
using System.Collections.Generic;
using Avalonia.Controls;

namespace {namespaceNameLocator}
{{
    public partial class {classNameLocator}
    {{");
        source.Append(value: @"
		private static Dictionary<Type, Func<Control>> s_views = new()
		{
");

        var userControlViewSymbol =
            compilation.GetTypeByMetadataName(fullyQualifiedMetadataName: "Avalonia.Controls.UserControl");

        foreach (var namedTypeSymbolViewModel in namedTypeSymbolViewModels)
        {
            var namespaceNameViewModel = namedTypeSymbolViewModel.ContainingNamespace.ToDisplayString();
            var classNameViewModel =
                $"{namespaceNameViewModel}.{namedTypeSymbolViewModel.ToDisplayString(format: format)}";
            var classNameView = classNameViewModel.Replace(oldValue: ViewModelSuffix, newValue: ViewSuffix);

            var classNameViewSymbol = compilation.GetTypeByMetadataName(fullyQualifiedMetadataName: classNameView);
            if (classNameViewSymbol is null || classNameViewSymbol.BaseType?.Equals(other: userControlViewSymbol
                    , equalityComparer: SymbolEqualityComparer.Default) != true)
            {
                source.AppendLine(
                    value:
                    $@"			[typeof({classNameViewModel})] = () => new TextBlock() {{ Text = {"\"Not Found: " + classNameView + "\""} }},");
            }
            else
            {
                source.AppendLine(value: $@"			[typeof({classNameViewModel})] = () => new {classNameView}(),");
            }
        }

        source.Append(value: @"		};
	}
}");

        return source.ToString();
    }

    private class SyntaxReceiver : ISyntaxContextReceiver
    {
        public List<INamedTypeSymbol> NamedTypeSymbolLocators
        {
            get;
        } = new();

        public List<INamedTypeSymbol> NamedTypeSymbolViewModels
        {
            get;
        } = new();

        public void OnVisitSyntaxNode(
            GeneratorSyntaxContext context
        )
        {
            if (context.Node is ClassDeclarationSyntax classDeclarationSyntax)
            {
                var namedTypeSymbol =
                    context.SemanticModel.GetDeclaredSymbol(declarationSyntax: classDeclarationSyntax);
                if (namedTypeSymbol is null)
                {
                    return;
                }

                var attributes = namedTypeSymbol.GetAttributes();
                if (attributes.Any(predicate: ad =>
                        ad?.AttributeClass?.ToDisplayString() == StaticViewLocatorAttributeDisplayString))
                {
                    NamedTypeSymbolLocators.Add(item: namedTypeSymbol);
                }
                else if (namedTypeSymbol.Name.EndsWith(value: ViewModelSuffix))
                {
                    if (!namedTypeSymbol.IsAbstract)
                    {
                        NamedTypeSymbolViewModels.Add(item: namedTypeSymbol);
                    }
                }
            }
        }
    }
}