using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ProjectAvalonia.Generators;

[Generator]
public class NavigationMetaDataGenerator : ISourceGenerator
{
    private const string NavigationMetaDataAttributeDisplayString = "ProjectAvalonia.NavigationMetaDataAttribute";

    private const string NavigationMetaDataDisplayString = "ProjectAvalonia.NavigationMetaData";

    private const string RoutableViewModelDisplayString = "ProjectAvalonia.ViewModels.Navigation.RoutableViewModel";

    private const string AttributeText = @"// <auto-generated />
using System;

namespace ProjectAvalonia
{
	public enum NavBarPosition
	{
		None,
		Top,
		Bottom
	}

	public enum NavigationTarget
	{
		Default = 0,
		HomeScreen = 1,
		DialogScreen = 2,
		FullScreen = 3,
		CompactDialogScreen = 4,
	}

	public sealed class NavigationMetaData
	{
		public bool Searchable { get; init; } = true;

		public string Title { get; init; }

        public string LocalizedTitle { get; init; }

		public string Caption { get; init; }

		public string IconName { get; init; }

		public string IconNameFocused { get; init; }

		public int Order { get; init; }

		public string Category { get; init; }

		public string[] Keywords { get; init; }

		public NavBarPosition NavBarPosition { get; init; }

		public NavigationTarget NavigationTarget { get; init; }
	}

	[AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
	public sealed class NavigationMetaDataAttribute : Attribute
	{
		public NavigationMetaDataAttribute()
		{
		}
        public string LocalizedTitle { get; set; }

		public bool Searchable { get; set; }

		public string Title { get; set; }

		public string Caption { get; set; }

		public string IconName { get; set; }

		public string IconNameFocused { get; set; }

		public int Order { get; set; }

		public string Category { get; set; }

		public string[] Keywords { get; set; }

		public NavBarPosition NavBarPosition {get; set; }

		public NavigationTarget NavigationTarget { get; set; }
	}
}";

    public void Initialize(
        GeneratorInitializationContext context
    )
    {
        /*System.Diagnostics.Debugger.Launch();*/

        /*var Resource = new ResourceManager(ProjectAvalonia.Generators);*/

        context.RegisterForPostInitialization(callback: i => i.AddSource(hintName: "NavigationMetaDataAttribute.cs"
            , sourceText: SourceText.From(text: AttributeText, encoding: Encoding.UTF8)));

        context.RegisterForSyntaxNotifications(receiverCreator: () => new SyntaxReceiver());
    }

    public void Execute(
        GeneratorExecutionContext context
    )
    {
        if (context.SyntaxContextReceiver is not SyntaxReceiver receiver)
        {
            return;
        }

        var attributeSymbol =
            context.Compilation.GetTypeByMetadataName(
                fullyQualifiedMetadataName: NavigationMetaDataAttributeDisplayString);
        if (attributeSymbol is null)
        {
            return;
        }

        var metadataSymbol =
            context.Compilation.GetTypeByMetadataName(fullyQualifiedMetadataName: NavigationMetaDataDisplayString);
        if (metadataSymbol is null)
        {
            return;
        }

        foreach (var namedTypeSymbol in receiver.NamedTypeSymbols)
        {
            var classSource = ProcessClass(compilation: context.Compilation, classSymbol: namedTypeSymbol
                , attributeSymbol: attributeSymbol, metadataSymbol: metadataSymbol);
            if (classSource is not null)
            {
                context.AddSource(hintName: $"{namedTypeSymbol.Name}_NavigationMetaData.cs"
                    , sourceText: SourceText.From(text: classSource, encoding: Encoding.UTF8));
            }
        }
    }

    private static string? ProcessClass(
        Compilation compilation
        , INamedTypeSymbol classSymbol
        , ISymbol attributeSymbol
        , ISymbol metadataSymbol
    )
    {
        if (!classSymbol.ContainingSymbol.Equals(other: classSymbol.ContainingNamespace,
                equalityComparer: SymbolEqualityComparer.Default))
        {
            return null;
        }

        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

        var format = new SymbolDisplayFormat(
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypes,
            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters |
                             SymbolDisplayGenericsOptions.IncludeTypeConstraints |
                             SymbolDisplayGenericsOptions.IncludeVariance
        );

        var source = new StringBuilder(value: $@"// <auto-generated />
#nullable enable
using System;
using System.Threading.Tasks;
using ProjectAvalonia.ViewModels.Navigation;

namespace {namespaceName}
{{
    public partial class {classSymbol.ToDisplayString(format: format)}
    {{
");

        var attributeData = classSymbol
            .GetAttributes()
            .Single(predicate: ad =>
                ad?.AttributeClass?.Equals(other: attributeSymbol, equalityComparer: SymbolEqualityComparer.Default) ??
                false);

        source.Append(value: $@"        public static {metadataSymbol.ToDisplayString()} MetaData {{ get; }} = new()
        {{
");
        var length = attributeData.NamedArguments.Length;
        for (var i = 0; i < length; i++)
        {
            var namedArgument = attributeData.NamedArguments[index: i];

            source.AppendLine(value: $"            {namedArgument.Key} = " +
                                     $"{(namedArgument.Value.Kind == TypedConstantKind.Array ? "new[] " : "")}" +
                                     $"{namedArgument.Value.ToCSharpString()}{(i < length - 1 ? "," : "")}");
        }

        source.Append(value: @"        };
");

        source.AppendLine(
            value:
            @"        public static void RegisterAsyncLazy(Func<Task<RoutableViewModel?>> createInstance) => NavigationManager.RegisterAsyncLazy(MetaData, createInstance);");
        source.AppendLine(
            value:
            @"        public static void RegisterLazy(Func<RoutableViewModel?> createInstance) => NavigationManager.RegisterLazy(MetaData, createInstance);");
        source.AppendLine(
            value:
            @"        public static void Register(RoutableViewModel createInstance) => NavigationManager.Register(MetaData, createInstance);");
        source.AppendLine(value: @"        public override string Title {get => MetaData.Title; protected set {} } ");

        var routeableClass =
            compilation.GetTypeByMetadataName(fullyQualifiedMetadataName: RoutableViewModelDisplayString);

        if (routeableClass is not null)
        {
            var addRouteableMetaData = false;
            var baseType = classSymbol.BaseType;
            while (true)
            {
                if (baseType is null)
                {
                    break;
                }

                if (SymbolEqualityComparer.Default.Equals(x: baseType, y: routeableClass))
                {
                    addRouteableMetaData = true;
                    break;
                }

                baseType = baseType.BaseType;
            }

            if (addRouteableMetaData)
            {
                if (attributeData.NamedArguments.Any(predicate: x => x.Key == "NavigationTarget"))
                {
                    source.AppendLine(
                        value: @"        public override NavigationTarget DefaultTarget => MetaData.NavigationTarget;");
                }

                if (attributeData.NamedArguments.Any(predicate: x => x.Key == "IconName"))
                {
                    source.AppendLine(value: @"        public override string IconName => MetaData.IconName;");
                }

                if (attributeData.NamedArguments.Any(predicate: x => x.Key == "IconNameFocused"))
                {
                    source.AppendLine(
                        value: @"        public override string IconNameFocused => MetaData.IconNameFocused;");
                }
            }
        }

        source.Append(value: @"    }
}");

        return source.ToString();
    }

    private class SyntaxReceiver : ISyntaxContextReceiver
    {
        public List<INamedTypeSymbol> NamedTypeSymbols
        {
            get;
        } = new();

        public void OnVisitSyntaxNode(
            GeneratorSyntaxContext context
        )
        {
            if (context.Node is ClassDeclarationSyntax classDeclarationSyntax
                && classDeclarationSyntax.AttributeLists.Count > 0)
            {
                var namedTypeSymbol =
                    context.SemanticModel.GetDeclaredSymbol(declarationSyntax: classDeclarationSyntax);
                if (namedTypeSymbol is null)
                {
                    return;
                }

                var attributes = namedTypeSymbol.GetAttributes();
                if (attributes.Any(predicate: ad =>
                        ad?.AttributeClass?.ToDisplayString() == NavigationMetaDataAttributeDisplayString))
                {
                    NamedTypeSymbols.Add(item: namedTypeSymbol);
                }
            }
        }
    }
}