using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ProjectAvalonia.Generators;

[Generator]
public class AutoNotifyGenerator : ISourceGenerator
{
    private const string AutoNotifyAttributeDisplayString = "ProjectAvalonia.AutoNotifyAttribute";

    private const string ReactiveObjectDisplayString = "ReactiveUI.ReactiveObject";

    private const string AttributeText = @"// <auto-generated />
#nullable enable
using System;

namespace ProjectAvalonia
{
    [AttributeUsage(AttributeTargets.Field, Inherited = false, AllowMultiple = false)]
    sealed class AutoNotifyAttribute : Attribute
    {
        public AutoNotifyAttribute()
        {
        }

        public string? PropertyName { get; set; }

		public AccessModifier SetterModifier { get; set; } = AccessModifier.Public;
    }
}";

    private const string ModifierText = @"// <auto-generated />

namespace ProjectAvalonia
{
    public enum AccessModifier
    {
        None = 0,
        Public = 1,
        Protected = 2,
        Private = 3,
        Internal = 4
    }
}";

    public void Initialize(
        GeneratorInitializationContext context
    )
    {
        /*System.Diagnostics.Debugger.Launch();*/
        context.RegisterForPostInitialization(callback: i =>
        {
            i.AddSource(hintName: "AccessModifier.cs"
                , sourceText: SourceText.From(text: ModifierText, encoding: Encoding.UTF8));
            i.AddSource(hintName: "AutoNotifyAttribute.cs"
                , sourceText: SourceText.From(text: AttributeText, encoding: Encoding.UTF8));
        });

        context.RegisterForSyntaxNotifications(receiverCreator: () => new SyntaxReceiver());
    }

    public void Execute(
        GeneratorExecutionContext context
    )
    {
        if (context.SyntaxContextReceiver is not SyntaxReceiver receiver)
        {
            return;
        }

        var attributeSymbol =
            context.Compilation.GetTypeByMetadataName(fullyQualifiedMetadataName: AutoNotifyAttributeDisplayString);
        if (attributeSymbol is null)
        {
            return;
        }

        var notifySymbol =
            context.Compilation.GetTypeByMetadataName(fullyQualifiedMetadataName: ReactiveObjectDisplayString);
        if (notifySymbol is null)
        {
            return;
        }

        // TODO: https://github.com/dotnet/roslyn/issues/49385
#pragma warning disable RS1024
        var groupedFields = receiver.FieldSymbols.GroupBy(keySelector: f => f.ContainingType);
#pragma warning restore RS1024

        foreach (var group in groupedFields)
        {
            var classSource = ProcessClass(classSymbol: group.Key, fields: group.ToList()
                , attributeSymbol: attributeSymbol, notifySymbol: notifySymbol);
            if (classSource is null)
            {
                continue;
            }

            context.AddSource(hintName: $"{group.Key.Name}_AutoNotify.cs"
                , sourceText: SourceText.From(text: classSource, encoding: Encoding.UTF8));
        }
    }

    private static string? ProcessClass(
        INamedTypeSymbol classSymbol
        , List<IFieldSymbol> fields
        , ISymbol attributeSymbol
        , INamedTypeSymbol notifySymbol
    )
    {
        if (!classSymbol.ContainingSymbol.Equals(other: classSymbol.ContainingNamespace
                , equalityComparer: SymbolEqualityComparer.Default))
        {
            return null;
        }

        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

        var addNotifyInterface = !classSymbol.Interfaces.Contains(item: notifySymbol);
        var baseType = classSymbol.BaseType;
        while (true)
        {
            if (baseType is null)
            {
                break;
            }

            if (SymbolEqualityComparer.Default.Equals(x: baseType, y: notifySymbol))
            {
                addNotifyInterface = false;
                break;
            }

            baseType = baseType.BaseType;
        }

        var source = new StringBuilder();

        var format = new SymbolDisplayFormat(
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypes,
            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters |
                             SymbolDisplayGenericsOptions.IncludeTypeConstraints |
                             SymbolDisplayGenericsOptions.IncludeVariance);

        if (addNotifyInterface)
        {
            source.Append(value: $@"// <auto-generated />
#nullable enable
using ReactiveUI;

namespace {namespaceName}
{{
    public partial class {classSymbol.ToDisplayString(format: format)} : {notifySymbol.ToDisplayString()}
    {{");
        }
        else
        {
            source.Append(value: $@"// <auto-generated />
#nullable enable
using ReactiveUI;

namespace {namespaceName}
{{
    public partial class {classSymbol.ToDisplayString(format: format)}
    {{");
        }

        foreach (var fieldSymbol in fields)
        {
            ProcessField(source: source, fieldSymbol: fieldSymbol, attributeSymbol: attributeSymbol);
        }

        source.Append(value: @"
    }
}");

        return source.ToString();
    }

    private static void ProcessField(
        StringBuilder source
        , IFieldSymbol fieldSymbol
        , ISymbol attributeSymbol
    )
    {
        var fieldName = fieldSymbol.Name;
        var fieldType = fieldSymbol.Type;
        var attributeData = fieldSymbol.GetAttributes().Single(predicate: ad =>
            ad?.AttributeClass?.Equals(other: attributeSymbol, equalityComparer: SymbolEqualityComparer.Default) ??
            false);
        var overridenNameOpt = attributeData.NamedArguments.SingleOrDefault(predicate: kvp => kvp.Key == "PropertyName")
            .Value;
        var propertyName = ChooseName(fieldName: fieldName, overridenNameOpt: overridenNameOpt);

        if (propertyName is null || propertyName.Length == 0 || propertyName == fieldName)
        {
            // Issue a diagnostic that we can't process this field.
            return;
        }

        var overridenSetterModifierOpt = attributeData.NamedArguments
            .SingleOrDefault(predicate: kvp => kvp.Key == "SetterModifier").Value;
        var setterModifier = ChooseSetterModifier(overridenSetterModifierOpt: overridenSetterModifierOpt);
        if (setterModifier is null)
        {
            source.Append(value: $@"
        public {fieldType} {propertyName}
        {{
            get => {fieldName};
        }}");
        }
        else
        {
            source.Append(value: $@"
        public {fieldType} {propertyName}
        {{
            get => {fieldName};
            {setterModifier}set => this.RaiseAndSetIfChanged(ref {fieldName}, value);
        }}");
        }

        static string? ChooseSetterModifier(
            TypedConstant overridenSetterModifierOpt
        )
        {
            if (!overridenSetterModifierOpt.IsNull && overridenSetterModifierOpt.Value is not null)
            {
                var value = (int)overridenSetterModifierOpt.Value;
                return value switch
                {
                    0 => null, // None
                    1 => ""
                    , // Public
                    2 => "protected "
                    , // Protected
                    3 => "private "
                    , // Private
                    4 => "internal "
                    , // Internal
                    _ => "" // Default
                };
            }

            return "";
        }

        static string? ChooseName(
            string fieldName
            , TypedConstant overridenNameOpt
        )
        {
            if (!overridenNameOpt.IsNull)
            {
                return overridenNameOpt.Value?.ToString();
            }

            fieldName = fieldName.TrimStart('_');
            if (fieldName.Length == 0)
            {
                return string.Empty;
            }

            if (fieldName.Length == 1)
            {
                return fieldName.ToUpper();
            }

            return fieldName.Substring(startIndex: 0, length: 1).ToUpper() + fieldName.Substring(startIndex: 1);
        }
    }

    private class SyntaxReceiver : ISyntaxContextReceiver
    {
        public List<IFieldSymbol> FieldSymbols
        {
            get;
        } = new();

        public void OnVisitSyntaxNode(
            GeneratorSyntaxContext context
        )
        {
            if (context.Node is FieldDeclarationSyntax fieldDeclarationSyntax
                && fieldDeclarationSyntax.AttributeLists.Count > 0)
            {
                foreach (var variable in fieldDeclarationSyntax.Declaration.Variables)
                {
                    if (context.SemanticModel.GetDeclaredSymbol(declaration: variable) is not IFieldSymbol fieldSymbol)
                    {
                        continue;
                    }

                    var attributes = fieldSymbol.GetAttributes();
                    if (attributes.Any(predicate: ad =>
                            ad?.AttributeClass?.ToDisplayString() == AutoNotifyAttributeDisplayString))
                    {
                        FieldSymbols.Add(item: fieldSymbol);
                    }
                }
            }
        }
    }
}